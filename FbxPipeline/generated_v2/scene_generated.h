// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_
#define FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_

#include "flatbuffers/flatbuffers.h"

namespace apemodefb {

struct vec2;

struct vec3;

struct vec4;

struct mat4;

struct StaticVertexFb;

struct PackedVertexFb;

struct StaticSkinnedVertexFb;

struct PackedSkinnedVertexFb;

struct AnimStackFb;

struct AnimLayerFb;

struct AnimCurveKeyFb;

struct AnimCurveFb;

struct TextureFb;

struct SubmeshFb;

struct SubsetFb;

struct NameFb;

struct TransformFb;

struct SkinFb;

struct MeshFb;

struct MaterialPropFb;

struct MaterialFb;

struct NodeFb;

struct FileFb;

struct SceneFb;

enum EVersion {
  EVersion_Value = 3,
  EVersion_MIN = EVersion_Value,
  EVersion_MAX = EVersion_Value
};

inline const char **EnumNamesEVersion() {
  static const char *names[] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVersion(EVersion e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(EVersion_Value);
  return EnumNamesEVersion()[index];
}

enum ECullingType {
  ECullingType_CullingOff = 0,
  ECullingType_CullingOnCCW = 1,
  ECullingType_CullingOnCW = 2,
  ECullingType_MIN = ECullingType_CullingOff,
  ECullingType_MAX = ECullingType_CullingOnCW
};

inline const char **EnumNamesECullingType() {
  static const char *names[] = {
    "CullingOff",
    "CullingOnCCW",
    "CullingOnCW",
    nullptr
  };
  return names;
}

inline const char *EnumNameECullingType(ECullingType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesECullingType()[index];
}

enum EWrapMode {
  EWrapMode_Repeat = 0,
  EWrapMode_Clamp = 1,
  EWrapMode_MIN = EWrapMode_Repeat,
  EWrapMode_MAX = EWrapMode_Clamp
};

inline const char **EnumNamesEWrapMode() {
  static const char *names[] = {
    "Repeat",
    "Clamp",
    nullptr
  };
  return names;
}

inline const char *EnumNameEWrapMode(EWrapMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEWrapMode()[index];
}

enum EBlendMode {
  EBlendMode_Translucent = 0,
  EBlendMode_Additive = 1,
  EBlendMode_Modulate = 2,
  EBlendMode_Modulate2 = 3,
  EBlendMode_Over = 4,
  EBlendMode_MIN = EBlendMode_Translucent,
  EBlendMode_MAX = EBlendMode_Over
};

inline const char **EnumNamesEBlendMode() {
  static const char *names[] = {
    "Translucent",
    "Additive",
    "Modulate",
    "Modulate2",
    "Over",
    nullptr
  };
  return names;
}

inline const char *EnumNameEBlendMode(EBlendMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEBlendMode()[index];
}

enum EVertexFormat {
  EVertexFormat_Static = 0,
  EVertexFormat_StaticSkinned = 1,
  EVertexFormat_Packed = 2,
  EVertexFormat_PackedSkinned = 3,
  EVertexFormat_MIN = EVertexFormat_Static,
  EVertexFormat_MAX = EVertexFormat_PackedSkinned
};

inline const char **EnumNamesEVertexFormat() {
  static const char *names[] = {
    "Static",
    "StaticSkinned",
    "Packed",
    "PackedSkinned",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVertexFormat(EVertexFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEVertexFormat()[index];
}

enum EIndexTypeFb {
  EIndexTypeFb_UInt16 = 0,
  EIndexTypeFb_UInt16Compressed = 1,
  EIndexTypeFb_UInt32 = 2,
  EIndexTypeFb_UInt32Compressed = 3,
  EIndexTypeFb_Count = 4,
  EIndexTypeFb_MIN = EIndexTypeFb_UInt16,
  EIndexTypeFb_MAX = EIndexTypeFb_Count
};

inline const char **EnumNamesEIndexTypeFb() {
  static const char *names[] = {
    "UInt16",
    "UInt16Compressed",
    "UInt32",
    "UInt32Compressed",
    "Count",
    nullptr
  };
  return names;
}

inline const char *EnumNameEIndexTypeFb(EIndexTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEIndexTypeFb()[index];
}

enum EMaterialPropTypeFb {
  EMaterialPropTypeFb_Bool = 0,
  EMaterialPropTypeFb_Float = 1,
  EMaterialPropTypeFb_Float2 = 2,
  EMaterialPropTypeFb_Float3 = 3,
  EMaterialPropTypeFb_Texture = 4,
  EMaterialPropTypeFb_MIN = EMaterialPropTypeFb_Bool,
  EMaterialPropTypeFb_MAX = EMaterialPropTypeFb_Texture
};

inline const char **EnumNamesEMaterialPropTypeFb() {
  static const char *names[] = {
    "Bool",
    "Float",
    "Float2",
    "Float3",
    "Texture",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMaterialPropTypeFb(EMaterialPropTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEMaterialPropTypeFb()[index];
}

enum EAnimCurveProperty {
  EAnimCurveProperty_LclTranslation = 0,
  EAnimCurveProperty_RotationOffset = 1,
  EAnimCurveProperty_RotationPivot = 2,
  EAnimCurveProperty_PreRotation = 3,
  EAnimCurveProperty_PostRotation = 4,
  EAnimCurveProperty_LclRotation = 5,
  EAnimCurveProperty_ScalingOffset = 6,
  EAnimCurveProperty_ScalingPivot = 7,
  EAnimCurveProperty_LclScaling = 8,
  EAnimCurveProperty_GeometricTranslation = 9,
  EAnimCurveProperty_GeometricRotation = 10,
  EAnimCurveProperty_GeometricScaling = 11,
  EAnimCurveProperty_MIN = EAnimCurveProperty_LclTranslation,
  EAnimCurveProperty_MAX = EAnimCurveProperty_GeometricScaling
};

inline const char **EnumNamesEAnimCurveProperty() {
  static const char *names[] = {
    "LclTranslation",
    "RotationOffset",
    "RotationPivot",
    "PreRotation",
    "PostRotation",
    "LclRotation",
    "ScalingOffset",
    "ScalingPivot",
    "LclScaling",
    "GeometricTranslation",
    "GeometricRotation",
    "GeometricScaling",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAnimCurveProperty(EAnimCurveProperty e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAnimCurveProperty()[index];
}

enum EAnimCurveChannel {
  EAnimCurveChannel_X = 0,
  EAnimCurveChannel_Y = 1,
  EAnimCurveChannel_Z = 2,
  EAnimCurveChannel_MIN = EAnimCurveChannel_X,
  EAnimCurveChannel_MAX = EAnimCurveChannel_Z
};

inline const char **EnumNamesEAnimCurveChannel() {
  static const char *names[] = {
    "X",
    "Y",
    "Z",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAnimCurveChannel(EAnimCurveChannel e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAnimCurveChannel()[index];
}

enum EInterpolationMode {
  EInterpolationMode_Const = 0,
  EInterpolationMode_Linear = 1,
  EInterpolationMode_Cubic = 2,
  EInterpolationMode_MIN = EInterpolationMode_Const,
  EInterpolationMode_MAX = EInterpolationMode_Cubic
};

inline const char **EnumNamesEInterpolationMode() {
  static const char *names[] = {
    "Const",
    "Linear",
    "Cubic",
    nullptr
  };
  return names;
}

inline const char *EnumNameEInterpolationMode(EInterpolationMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEInterpolationMode()[index];
}

MANUALLY_ALIGNED_STRUCT(4) vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  vec2() {
    memset(this, 0, sizeof(vec2));
  }
  vec2(const vec2 &_o) {
    memcpy(this, &_o, sizeof(vec2));
  }
  vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
STRUCT_END(vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  vec3() {
    memset(this, 0, sizeof(vec3));
  }
  vec3(const vec3 &_o) {
    memcpy(this, &_o, sizeof(vec3));
  }
  vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
STRUCT_END(vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  vec4() {
    memset(this, 0, sizeof(vec4));
  }
  vec4(const vec4 &_o) {
    memcpy(this, &_o, sizeof(vec4));
  }
  vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
STRUCT_END(vec4, 16);

MANUALLY_ALIGNED_STRUCT(4) mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  vec4 x_;
  vec4 y_;
  vec4 z_;
  vec4 w_;

 public:
  mat4() {
    memset(this, 0, sizeof(mat4));
  }
  mat4(const mat4 &_o) {
    memcpy(this, &_o, sizeof(mat4));
  }
  mat4(const vec4 &_x, const vec4 &_y, const vec4 &_z, const vec4 &_w)
      : x_(_x),
        y_(_y),
        z_(_z),
        w_(_w) {
  }
  const vec4 &x() const {
    return x_;
  }
  const vec4 &mutable_x() {
    return x_;
  }
  const vec4 &y() const {
    return y_;
  }
  const vec4 &mutable_y() {
    return y_;
  }
  const vec4 &z() const {
    return z_;
  }
  const vec4 &mutable_z() {
    return z_;
  }
  const vec4 &w() const {
    return w_;
  }
  const vec4 &mutable_w() {
    return w_;
  }
};
STRUCT_END(mat4, 64);

MANUALLY_ALIGNED_STRUCT(4) StaticVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  vec3 position_;
  vec3 normal_;
  vec4 tangent_;
  vec2 uv_;

 public:
  StaticVertexFb() {
    memset(this, 0, sizeof(StaticVertexFb));
  }
  StaticVertexFb(const StaticVertexFb &_o) {
    memcpy(this, &_o, sizeof(StaticVertexFb));
  }
  StaticVertexFb(const vec3 &_position, const vec3 &_normal, const vec4 &_tangent, const vec2 &_uv)
      : position_(_position),
        normal_(_normal),
        tangent_(_tangent),
        uv_(_uv) {
  }
  const vec3 &position() const {
    return position_;
  }
  const vec3 &mutable_position() {
    return position_;
  }
  const vec3 &normal() const {
    return normal_;
  }
  const vec3 &mutable_normal() {
    return normal_;
  }
  const vec4 &tangent() const {
    return tangent_;
  }
  const vec4 &mutable_tangent() {
    return tangent_;
  }
  const vec2 &uv() const {
    return uv_;
  }
  const vec2 &mutable_uv() {
    return uv_;
  }
};
STRUCT_END(StaticVertexFb, 48);

MANUALLY_ALIGNED_STRUCT(4) PackedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t position_;
  uint32_t normal_;
  uint32_t tangent_;
  uint32_t uv_;

 public:
  PackedVertexFb() {
    memset(this, 0, sizeof(PackedVertexFb));
  }
  PackedVertexFb(const PackedVertexFb &_o) {
    memcpy(this, &_o, sizeof(PackedVertexFb));
  }
  PackedVertexFb(uint32_t _position, uint32_t _normal, uint32_t _tangent, uint32_t _uv)
      : position_(flatbuffers::EndianScalar(_position)),
        normal_(flatbuffers::EndianScalar(_normal)),
        tangent_(flatbuffers::EndianScalar(_tangent)),
        uv_(flatbuffers::EndianScalar(_uv)) {
  }
  uint32_t position() const {
    return flatbuffers::EndianScalar(position_);
  }
  void mutate_position(uint32_t _position) {
    flatbuffers::WriteScalar(&position_, _position);
  }
  uint32_t normal() const {
    return flatbuffers::EndianScalar(normal_);
  }
  void mutate_normal(uint32_t _normal) {
    flatbuffers::WriteScalar(&normal_, _normal);
  }
  uint32_t tangent() const {
    return flatbuffers::EndianScalar(tangent_);
  }
  void mutate_tangent(uint32_t _tangent) {
    flatbuffers::WriteScalar(&tangent_, _tangent);
  }
  uint32_t uv() const {
    return flatbuffers::EndianScalar(uv_);
  }
  void mutate_uv(uint32_t _uv) {
    flatbuffers::WriteScalar(&uv_, _uv);
  }
};
STRUCT_END(PackedVertexFb, 16);

MANUALLY_ALIGNED_STRUCT(4) StaticSkinnedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  vec3 position_;
  vec3 normal_;
  vec4 tangent_;
  vec2 uv_;
  vec4 weights_;
  vec4 indices_;

 public:
  StaticSkinnedVertexFb() {
    memset(this, 0, sizeof(StaticSkinnedVertexFb));
  }
  StaticSkinnedVertexFb(const StaticSkinnedVertexFb &_o) {
    memcpy(this, &_o, sizeof(StaticSkinnedVertexFb));
  }
  StaticSkinnedVertexFb(const vec3 &_position, const vec3 &_normal, const vec4 &_tangent, const vec2 &_uv, const vec4 &_weights, const vec4 &_indices)
      : position_(_position),
        normal_(_normal),
        tangent_(_tangent),
        uv_(_uv),
        weights_(_weights),
        indices_(_indices) {
  }
  const vec3 &position() const {
    return position_;
  }
  const vec3 &mutable_position() {
    return position_;
  }
  const vec3 &normal() const {
    return normal_;
  }
  const vec3 &mutable_normal() {
    return normal_;
  }
  const vec4 &tangent() const {
    return tangent_;
  }
  const vec4 &mutable_tangent() {
    return tangent_;
  }
  const vec2 &uv() const {
    return uv_;
  }
  const vec2 &mutable_uv() {
    return uv_;
  }
  const vec4 &weights() const {
    return weights_;
  }
  const vec4 &mutable_weights() {
    return weights_;
  }
  const vec4 &indices() const {
    return indices_;
  }
  const vec4 &mutable_indices() {
    return indices_;
  }
};
STRUCT_END(StaticSkinnedVertexFb, 80);

MANUALLY_ALIGNED_STRUCT(4) PackedSkinnedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t position_;
  uint32_t normal_;
  uint32_t tangent_;
  uint32_t uv_;
  uint32_t weights_;
  uint32_t indices_;

 public:
  PackedSkinnedVertexFb() {
    memset(this, 0, sizeof(PackedSkinnedVertexFb));
  }
  PackedSkinnedVertexFb(const PackedSkinnedVertexFb &_o) {
    memcpy(this, &_o, sizeof(PackedSkinnedVertexFb));
  }
  PackedSkinnedVertexFb(uint32_t _position, uint32_t _normal, uint32_t _tangent, uint32_t _uv, uint32_t _weights, uint32_t _indices)
      : position_(flatbuffers::EndianScalar(_position)),
        normal_(flatbuffers::EndianScalar(_normal)),
        tangent_(flatbuffers::EndianScalar(_tangent)),
        uv_(flatbuffers::EndianScalar(_uv)),
        weights_(flatbuffers::EndianScalar(_weights)),
        indices_(flatbuffers::EndianScalar(_indices)) {
  }
  uint32_t position() const {
    return flatbuffers::EndianScalar(position_);
  }
  void mutate_position(uint32_t _position) {
    flatbuffers::WriteScalar(&position_, _position);
  }
  uint32_t normal() const {
    return flatbuffers::EndianScalar(normal_);
  }
  void mutate_normal(uint32_t _normal) {
    flatbuffers::WriteScalar(&normal_, _normal);
  }
  uint32_t tangent() const {
    return flatbuffers::EndianScalar(tangent_);
  }
  void mutate_tangent(uint32_t _tangent) {
    flatbuffers::WriteScalar(&tangent_, _tangent);
  }
  uint32_t uv() const {
    return flatbuffers::EndianScalar(uv_);
  }
  void mutate_uv(uint32_t _uv) {
    flatbuffers::WriteScalar(&uv_, _uv);
  }
  uint32_t weights() const {
    return flatbuffers::EndianScalar(weights_);
  }
  void mutate_weights(uint32_t _weights) {
    flatbuffers::WriteScalar(&weights_, _weights);
  }
  uint32_t indices() const {
    return flatbuffers::EndianScalar(indices_);
  }
  void mutate_indices(uint32_t _indices) {
    flatbuffers::WriteScalar(&indices_, _indices);
  }
};
STRUCT_END(PackedSkinnedVertexFb, 24);

MANUALLY_ALIGNED_STRUCT(8) AnimStackFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  int32_t padding0__;
  uint64_t name_id_;

 public:
  AnimStackFb() {
    memset(this, 0, sizeof(AnimStackFb));
  }
  AnimStackFb(const AnimStackFb &_o) {
    memcpy(this, &_o, sizeof(AnimStackFb));
  }
  AnimStackFb(uint32_t _id, uint64_t _name_id)
      : id_(flatbuffers::EndianScalar(_id)),
        padding0__(0),
        name_id_(flatbuffers::EndianScalar(_name_id)) {
    (void)padding0__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint64_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint64_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
};
STRUCT_END(AnimStackFb, 16);

MANUALLY_ALIGNED_STRUCT(8) AnimLayerFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t anim_stack_id_;
  uint64_t name_id_;

 public:
  AnimLayerFb() {
    memset(this, 0, sizeof(AnimLayerFb));
  }
  AnimLayerFb(const AnimLayerFb &_o) {
    memcpy(this, &_o, sizeof(AnimLayerFb));
  }
  AnimLayerFb(uint32_t _id, uint32_t _anim_stack_id, uint64_t _name_id)
      : id_(flatbuffers::EndianScalar(_id)),
        anim_stack_id_(flatbuffers::EndianScalar(_anim_stack_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)) {
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t anim_stack_id() const {
    return flatbuffers::EndianScalar(anim_stack_id_);
  }
  void mutate_anim_stack_id(uint32_t _anim_stack_id) {
    flatbuffers::WriteScalar(&anim_stack_id_, _anim_stack_id);
  }
  uint64_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint64_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
};
STRUCT_END(AnimLayerFb, 16);

MANUALLY_ALIGNED_STRUCT(4) AnimCurveKeyFb FLATBUFFERS_FINAL_CLASS {
 private:
  float time_;
  float value_;

 public:
  AnimCurveKeyFb() {
    memset(this, 0, sizeof(AnimCurveKeyFb));
  }
  AnimCurveKeyFb(const AnimCurveKeyFb &_o) {
    memcpy(this, &_o, sizeof(AnimCurveKeyFb));
  }
  AnimCurveKeyFb(float _time, float _value)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(float _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  float value() const {
    return flatbuffers::EndianScalar(value_);
  }
  void mutate_value(float _value) {
    flatbuffers::WriteScalar(&value_, _value);
  }
};
STRUCT_END(AnimCurveKeyFb, 8);

MANUALLY_ALIGNED_STRUCT(8) TextureFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  int32_t padding0__;
  uint64_t name_id_;
  uint32_t file_id_;
  uint32_t blend_mode_;
  uint32_t wrap_mode_u_;
  uint32_t wrap_mode_v_;
  float offset_u_;
  float offset_v_;
  float scale_u_;
  float scale_v_;

 public:
  TextureFb() {
    memset(this, 0, sizeof(TextureFb));
  }
  TextureFb(const TextureFb &_o) {
    memcpy(this, &_o, sizeof(TextureFb));
  }
  TextureFb(uint32_t _id, uint64_t _name_id, uint32_t _file_id, EBlendMode _blend_mode, EWrapMode _wrap_mode_u, EWrapMode _wrap_mode_v, float _offset_u, float _offset_v, float _scale_u, float _scale_v)
      : id_(flatbuffers::EndianScalar(_id)),
        padding0__(0),
        name_id_(flatbuffers::EndianScalar(_name_id)),
        file_id_(flatbuffers::EndianScalar(_file_id)),
        blend_mode_(flatbuffers::EndianScalar(static_cast<uint32_t>(_blend_mode))),
        wrap_mode_u_(flatbuffers::EndianScalar(static_cast<uint32_t>(_wrap_mode_u))),
        wrap_mode_v_(flatbuffers::EndianScalar(static_cast<uint32_t>(_wrap_mode_v))),
        offset_u_(flatbuffers::EndianScalar(_offset_u)),
        offset_v_(flatbuffers::EndianScalar(_offset_v)),
        scale_u_(flatbuffers::EndianScalar(_scale_u)),
        scale_v_(flatbuffers::EndianScalar(_scale_v)) {
    (void)padding0__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint64_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint64_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  uint32_t file_id() const {
    return flatbuffers::EndianScalar(file_id_);
  }
  void mutate_file_id(uint32_t _file_id) {
    flatbuffers::WriteScalar(&file_id_, _file_id);
  }
  EBlendMode blend_mode() const {
    return static_cast<EBlendMode>(flatbuffers::EndianScalar(blend_mode_));
  }
  void mutate_blend_mode(EBlendMode _blend_mode) {
    flatbuffers::WriteScalar(&blend_mode_, static_cast<uint32_t>(_blend_mode));
  }
  EWrapMode wrap_mode_u() const {
    return static_cast<EWrapMode>(flatbuffers::EndianScalar(wrap_mode_u_));
  }
  void mutate_wrap_mode_u(EWrapMode _wrap_mode_u) {
    flatbuffers::WriteScalar(&wrap_mode_u_, static_cast<uint32_t>(_wrap_mode_u));
  }
  EWrapMode wrap_mode_v() const {
    return static_cast<EWrapMode>(flatbuffers::EndianScalar(wrap_mode_v_));
  }
  void mutate_wrap_mode_v(EWrapMode _wrap_mode_v) {
    flatbuffers::WriteScalar(&wrap_mode_v_, static_cast<uint32_t>(_wrap_mode_v));
  }
  float offset_u() const {
    return flatbuffers::EndianScalar(offset_u_);
  }
  void mutate_offset_u(float _offset_u) {
    flatbuffers::WriteScalar(&offset_u_, _offset_u);
  }
  float offset_v() const {
    return flatbuffers::EndianScalar(offset_v_);
  }
  void mutate_offset_v(float _offset_v) {
    flatbuffers::WriteScalar(&offset_v_, _offset_v);
  }
  float scale_u() const {
    return flatbuffers::EndianScalar(scale_u_);
  }
  void mutate_scale_u(float _scale_u) {
    flatbuffers::WriteScalar(&scale_u_, _scale_u);
  }
  float scale_v() const {
    return flatbuffers::EndianScalar(scale_v_);
  }
  void mutate_scale_v(float _scale_v) {
    flatbuffers::WriteScalar(&scale_v_, _scale_v);
  }
};
STRUCT_END(TextureFb, 48);

MANUALLY_ALIGNED_STRUCT(4) SubmeshFb FLATBUFFERS_FINAL_CLASS {
 private:
  vec3 bbox_min_;
  vec3 bbox_max_;
  vec3 position_offset_;
  vec3 position_scale_;
  vec2 uv_offset_;
  vec2 uv_scale_;
  uint32_t base_vertex_;
  uint32_t vertex_count_;
  uint32_t base_index_;
  uint32_t index_count_;
  uint16_t base_subset_;
  uint16_t subset_count_;
  uint32_t vertex_format_;
  uint16_t vertex_stride_;
  int16_t padding0__;

 public:
  SubmeshFb() {
    memset(this, 0, sizeof(SubmeshFb));
  }
  SubmeshFb(const SubmeshFb &_o) {
    memcpy(this, &_o, sizeof(SubmeshFb));
  }
  SubmeshFb(const vec3 &_bbox_min, const vec3 &_bbox_max, const vec3 &_position_offset, const vec3 &_position_scale, const vec2 &_uv_offset, const vec2 &_uv_scale, uint32_t _base_vertex, uint32_t _vertex_count, uint32_t _base_index, uint32_t _index_count, uint16_t _base_subset, uint16_t _subset_count, EVertexFormat _vertex_format, uint16_t _vertex_stride)
      : bbox_min_(_bbox_min),
        bbox_max_(_bbox_max),
        position_offset_(_position_offset),
        position_scale_(_position_scale),
        uv_offset_(_uv_offset),
        uv_scale_(_uv_scale),
        base_vertex_(flatbuffers::EndianScalar(_base_vertex)),
        vertex_count_(flatbuffers::EndianScalar(_vertex_count)),
        base_index_(flatbuffers::EndianScalar(_base_index)),
        index_count_(flatbuffers::EndianScalar(_index_count)),
        base_subset_(flatbuffers::EndianScalar(_base_subset)),
        subset_count_(flatbuffers::EndianScalar(_subset_count)),
        vertex_format_(flatbuffers::EndianScalar(static_cast<uint32_t>(_vertex_format))),
        vertex_stride_(flatbuffers::EndianScalar(_vertex_stride)),
        padding0__(0) {
    (void)padding0__;
  }
  const vec3 &bbox_min() const {
    return bbox_min_;
  }
  const vec3 &mutable_bbox_min() {
    return bbox_min_;
  }
  const vec3 &bbox_max() const {
    return bbox_max_;
  }
  const vec3 &mutable_bbox_max() {
    return bbox_max_;
  }
  const vec3 &position_offset() const {
    return position_offset_;
  }
  const vec3 &mutable_position_offset() {
    return position_offset_;
  }
  const vec3 &position_scale() const {
    return position_scale_;
  }
  const vec3 &mutable_position_scale() {
    return position_scale_;
  }
  const vec2 &uv_offset() const {
    return uv_offset_;
  }
  const vec2 &mutable_uv_offset() {
    return uv_offset_;
  }
  const vec2 &uv_scale() const {
    return uv_scale_;
  }
  const vec2 &mutable_uv_scale() {
    return uv_scale_;
  }
  uint32_t base_vertex() const {
    return flatbuffers::EndianScalar(base_vertex_);
  }
  void mutate_base_vertex(uint32_t _base_vertex) {
    flatbuffers::WriteScalar(&base_vertex_, _base_vertex);
  }
  uint32_t vertex_count() const {
    return flatbuffers::EndianScalar(vertex_count_);
  }
  void mutate_vertex_count(uint32_t _vertex_count) {
    flatbuffers::WriteScalar(&vertex_count_, _vertex_count);
  }
  uint32_t base_index() const {
    return flatbuffers::EndianScalar(base_index_);
  }
  void mutate_base_index(uint32_t _base_index) {
    flatbuffers::WriteScalar(&base_index_, _base_index);
  }
  uint32_t index_count() const {
    return flatbuffers::EndianScalar(index_count_);
  }
  void mutate_index_count(uint32_t _index_count) {
    flatbuffers::WriteScalar(&index_count_, _index_count);
  }
  uint16_t base_subset() const {
    return flatbuffers::EndianScalar(base_subset_);
  }
  void mutate_base_subset(uint16_t _base_subset) {
    flatbuffers::WriteScalar(&base_subset_, _base_subset);
  }
  uint16_t subset_count() const {
    return flatbuffers::EndianScalar(subset_count_);
  }
  void mutate_subset_count(uint16_t _subset_count) {
    flatbuffers::WriteScalar(&subset_count_, _subset_count);
  }
  EVertexFormat vertex_format() const {
    return static_cast<EVertexFormat>(flatbuffers::EndianScalar(vertex_format_));
  }
  void mutate_vertex_format(EVertexFormat _vertex_format) {
    flatbuffers::WriteScalar(&vertex_format_, static_cast<uint32_t>(_vertex_format));
  }
  uint16_t vertex_stride() const {
    return flatbuffers::EndianScalar(vertex_stride_);
  }
  void mutate_vertex_stride(uint16_t _vertex_stride) {
    flatbuffers::WriteScalar(&vertex_stride_, _vertex_stride);
  }
};
STRUCT_END(SubmeshFb, 92);

MANUALLY_ALIGNED_STRUCT(4) SubsetFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t material_id_;
  uint32_t base_index_;
  uint32_t index_count_;

 public:
  SubsetFb() {
    memset(this, 0, sizeof(SubsetFb));
  }
  SubsetFb(const SubsetFb &_o) {
    memcpy(this, &_o, sizeof(SubsetFb));
  }
  SubsetFb(uint32_t _material_id, uint32_t _base_index, uint32_t _index_count)
      : material_id_(flatbuffers::EndianScalar(_material_id)),
        base_index_(flatbuffers::EndianScalar(_base_index)),
        index_count_(flatbuffers::EndianScalar(_index_count)) {
  }
  uint32_t material_id() const {
    return flatbuffers::EndianScalar(material_id_);
  }
  void mutate_material_id(uint32_t _material_id) {
    flatbuffers::WriteScalar(&material_id_, _material_id);
  }
  uint32_t base_index() const {
    return flatbuffers::EndianScalar(base_index_);
  }
  void mutate_base_index(uint32_t _base_index) {
    flatbuffers::WriteScalar(&base_index_, _base_index);
  }
  uint32_t index_count() const {
    return flatbuffers::EndianScalar(index_count_);
  }
  void mutate_index_count(uint32_t _index_count) {
    flatbuffers::WriteScalar(&index_count_, _index_count);
  }
};
STRUCT_END(SubsetFb, 12);

MANUALLY_ALIGNED_STRUCT(4) TransformFb FLATBUFFERS_FINAL_CLASS {
 private:
  vec3 translation_;
  vec3 rotation_offset_;
  vec3 rotation_pivot_;
  vec3 pre_rotation_;
  vec3 post_rotation_;
  vec3 rotation_;
  vec3 scaling_offset_;
  vec3 scaling_pivot_;
  vec3 scaling_;
  vec3 geometric_translation_;
  vec3 geometric_rotation_;
  vec3 geometric_scaling_;

 public:
  TransformFb() {
    memset(this, 0, sizeof(TransformFb));
  }
  TransformFb(const TransformFb &_o) {
    memcpy(this, &_o, sizeof(TransformFb));
  }
  TransformFb(const vec3 &_translation, const vec3 &_rotation_offset, const vec3 &_rotation_pivot, const vec3 &_pre_rotation, const vec3 &_post_rotation, const vec3 &_rotation, const vec3 &_scaling_offset, const vec3 &_scaling_pivot, const vec3 &_scaling, const vec3 &_geometric_translation, const vec3 &_geometric_rotation, const vec3 &_geometric_scaling)
      : translation_(_translation),
        rotation_offset_(_rotation_offset),
        rotation_pivot_(_rotation_pivot),
        pre_rotation_(_pre_rotation),
        post_rotation_(_post_rotation),
        rotation_(_rotation),
        scaling_offset_(_scaling_offset),
        scaling_pivot_(_scaling_pivot),
        scaling_(_scaling),
        geometric_translation_(_geometric_translation),
        geometric_rotation_(_geometric_rotation),
        geometric_scaling_(_geometric_scaling) {
  }
  const vec3 &translation() const {
    return translation_;
  }
  const vec3 &mutable_translation() {
    return translation_;
  }
  const vec3 &rotation_offset() const {
    return rotation_offset_;
  }
  const vec3 &mutable_rotation_offset() {
    return rotation_offset_;
  }
  const vec3 &rotation_pivot() const {
    return rotation_pivot_;
  }
  const vec3 &mutable_rotation_pivot() {
    return rotation_pivot_;
  }
  const vec3 &pre_rotation() const {
    return pre_rotation_;
  }
  const vec3 &mutable_pre_rotation() {
    return pre_rotation_;
  }
  const vec3 &post_rotation() const {
    return post_rotation_;
  }
  const vec3 &mutable_post_rotation() {
    return post_rotation_;
  }
  const vec3 &rotation() const {
    return rotation_;
  }
  const vec3 &mutable_rotation() {
    return rotation_;
  }
  const vec3 &scaling_offset() const {
    return scaling_offset_;
  }
  const vec3 &mutable_scaling_offset() {
    return scaling_offset_;
  }
  const vec3 &scaling_pivot() const {
    return scaling_pivot_;
  }
  const vec3 &mutable_scaling_pivot() {
    return scaling_pivot_;
  }
  const vec3 &scaling() const {
    return scaling_;
  }
  const vec3 &mutable_scaling() {
    return scaling_;
  }
  const vec3 &geometric_translation() const {
    return geometric_translation_;
  }
  const vec3 &mutable_geometric_translation() {
    return geometric_translation_;
  }
  const vec3 &geometric_rotation() const {
    return geometric_rotation_;
  }
  const vec3 &mutable_geometric_rotation() {
    return geometric_rotation_;
  }
  const vec3 &geometric_scaling() const {
    return geometric_scaling_;
  }
  const vec3 &mutable_geometric_scaling() {
    return geometric_scaling_;
  }
};
STRUCT_END(TransformFb, 144);

MANUALLY_ALIGNED_STRUCT(8) MaterialPropFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t name_id_;
  uint32_t type_;
  vec3 value_;

 public:
  MaterialPropFb() {
    memset(this, 0, sizeof(MaterialPropFb));
  }
  MaterialPropFb(const MaterialPropFb &_o) {
    memcpy(this, &_o, sizeof(MaterialPropFb));
  }
  MaterialPropFb(uint64_t _name_id, EMaterialPropTypeFb _type, const vec3 &_value)
      : name_id_(flatbuffers::EndianScalar(_name_id)),
        type_(flatbuffers::EndianScalar(static_cast<uint32_t>(_type))),
        value_(_value) {
  }
  uint64_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint64_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  EMaterialPropTypeFb type() const {
    return static_cast<EMaterialPropTypeFb>(flatbuffers::EndianScalar(type_));
  }
  void mutate_type(EMaterialPropTypeFb _type) {
    flatbuffers::WriteScalar(&type_, static_cast<uint32_t>(_type));
  }
  const vec3 &value() const {
    return value_;
  }
  const vec3 &mutable_value() {
    return value_;
  }
};
STRUCT_END(MaterialPropFb, 24);

struct AnimCurveFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_PROPERTY = 8,
    VT_CHANNEL = 10,
    VT_KEYS = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField(VT_ID, _id);
  }
  uint64_t name_id() const {
    return GetField<uint64_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint64_t _name_id) {
    return SetField(VT_NAME_ID, _name_id);
  }
  bool KeyCompareLessThan(const AnimCurveFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  EAnimCurveProperty property() const {
    return static_cast<EAnimCurveProperty>(GetField<uint32_t>(VT_PROPERTY, 0));
  }
  bool mutate_property(EAnimCurveProperty _property) {
    return SetField(VT_PROPERTY, static_cast<uint32_t>(_property));
  }
  EAnimCurveChannel channel() const {
    return static_cast<EAnimCurveChannel>(GetField<uint32_t>(VT_CHANNEL, 0));
  }
  bool mutate_channel(EAnimCurveChannel _channel) {
    return SetField(VT_CHANNEL, static_cast<uint32_t>(_channel));
  }
  const flatbuffers::Vector<const AnimCurveKeyFb *> *keys() const {
    return GetPointer<const flatbuffers::Vector<const AnimCurveKeyFb *> *>(VT_KEYS);
  }
  flatbuffers::Vector<const AnimCurveKeyFb *> *mutable_keys() {
    return GetPointer<flatbuffers::Vector<const AnimCurveKeyFb *> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint64_t>(verifier, VT_NAME_ID) &&
           VerifyField<uint32_t>(verifier, VT_PROPERTY) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_KEYS) &&
           verifier.Verify(keys()) &&
           verifier.EndTable();
  }
};

struct AnimCurveFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AnimCurveFb::VT_ID, id, 0);
  }
  void add_name_id(uint64_t name_id) {
    fbb_.AddElement<uint64_t>(AnimCurveFb::VT_NAME_ID, name_id, 0);
  }
  void add_property(EAnimCurveProperty property) {
    fbb_.AddElement<uint32_t>(AnimCurveFb::VT_PROPERTY, static_cast<uint32_t>(property), 0);
  }
  void add_channel(EAnimCurveChannel channel) {
    fbb_.AddElement<uint32_t>(AnimCurveFb::VT_CHANNEL, static_cast<uint32_t>(channel), 0);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<const AnimCurveKeyFb *>> keys) {
    fbb_.AddOffset(AnimCurveFb::VT_KEYS, keys);
  }
  AnimCurveFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimCurveFbBuilder &operator=(const AnimCurveFbBuilder &);
  flatbuffers::Offset<AnimCurveFb> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<AnimCurveFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimCurveFb> CreateAnimCurveFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    EAnimCurveProperty property = EAnimCurveProperty_LclTranslation,
    EAnimCurveChannel channel = EAnimCurveChannel_X,
    flatbuffers::Offset<flatbuffers::Vector<const AnimCurveKeyFb *>> keys = 0) {
  AnimCurveFbBuilder builder_(_fbb);
  builder_.add_name_id(name_id);
  builder_.add_keys(keys);
  builder_.add_channel(channel);
  builder_.add_property(property);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveFb> CreateAnimCurveFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    EAnimCurveProperty property = EAnimCurveProperty_LclTranslation,
    EAnimCurveChannel channel = EAnimCurveChannel_X,
    const std::vector<const AnimCurveKeyFb *> *keys = nullptr) {
  return CreateAnimCurveFb(
      _fbb,
      id,
      name_id,
      property,
      channel,
      keys ? _fbb.CreateVector<const AnimCurveKeyFb *>(*keys) : 0);
}

struct NameFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_H = 4,
    VT_V = 6
  };
  uint64_t h() const {
    return GetField<uint64_t>(VT_H, 0);
  }
  bool mutate_h(uint64_t _h) {
    return SetField(VT_H, _h);
  }
  bool KeyCompareLessThan(const NameFb *o) const {
    return h() < o->h();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = h();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_H) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct NameFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_h(uint64_t h) {
    fbb_.AddElement<uint64_t>(NameFb::VT_H, h, 0);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(NameFb::VT_V, v);
  }
  NameFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NameFbBuilder &operator=(const NameFbBuilder &);
  flatbuffers::Offset<NameFb> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NameFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<NameFb> CreateNameFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t h = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  NameFbBuilder builder_(_fbb);
  builder_.add_h(h);
  builder_.add_v(v);
  return builder_.Finish();
}

inline flatbuffers::Offset<NameFb> CreateNameFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t h = 0,
    const char *v = nullptr) {
  return CreateNameFb(
      _fbb,
      h,
      v ? _fbb.CreateString(v) : 0);
}

struct SkinFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME_ID = 4,
    VT_LINKS_IDS = 6
  };
  uint64_t name_id() const {
    return GetField<uint64_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint64_t _name_id) {
    return SetField(VT_NAME_ID, _name_id);
  }
  bool KeyCompareLessThan(const SkinFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<uint32_t> *links_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LINKS_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_links_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_LINKS_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NAME_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LINKS_IDS) &&
           verifier.Verify(links_ids()) &&
           verifier.EndTable();
  }
};

struct SkinFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_id(uint64_t name_id) {
    fbb_.AddElement<uint64_t>(SkinFb::VT_NAME_ID, name_id, 0);
  }
  void add_links_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> links_ids) {
    fbb_.AddOffset(SkinFb::VT_LINKS_IDS, links_ids);
  }
  SkinFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkinFbBuilder &operator=(const SkinFbBuilder &);
  flatbuffers::Offset<SkinFb> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<SkinFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkinFb> CreateSkinFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> links_ids = 0) {
  SkinFbBuilder builder_(_fbb);
  builder_.add_name_id(name_id);
  builder_.add_links_ids(links_ids);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkinFb> CreateSkinFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t name_id = 0,
    const std::vector<uint32_t> *links_ids = nullptr) {
  return CreateSkinFb(
      _fbb,
      name_id,
      links_ids ? _fbb.CreateVector<uint32_t>(*links_ids) : 0);
}

struct MeshFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERTICES = 4,
    VT_SUBMESHES = 6,
    VT_SUBSETS = 8,
    VT_INDICES = 10,
    VT_INDEX_TYPE = 12,
    VT_SKIN_ID = 14
  };
  const flatbuffers::Vector<uint8_t> *vertices() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VERTICES);
  }
  flatbuffers::Vector<uint8_t> *mutable_vertices() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<const SubmeshFb *> *submeshes() const {
    return GetPointer<const flatbuffers::Vector<const SubmeshFb *> *>(VT_SUBMESHES);
  }
  flatbuffers::Vector<const SubmeshFb *> *mutable_submeshes() {
    return GetPointer<flatbuffers::Vector<const SubmeshFb *> *>(VT_SUBMESHES);
  }
  const flatbuffers::Vector<const SubsetFb *> *subsets() const {
    return GetPointer<const flatbuffers::Vector<const SubsetFb *> *>(VT_SUBSETS);
  }
  flatbuffers::Vector<const SubsetFb *> *mutable_subsets() {
    return GetPointer<flatbuffers::Vector<const SubsetFb *> *>(VT_SUBSETS);
  }
  const flatbuffers::Vector<uint8_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INDICES);
  }
  flatbuffers::Vector<uint8_t> *mutable_indices() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INDICES);
  }
  EIndexTypeFb index_type() const {
    return static_cast<EIndexTypeFb>(GetField<uint32_t>(VT_INDEX_TYPE, 0));
  }
  bool mutate_index_type(EIndexTypeFb _index_type) {
    return SetField(VT_INDEX_TYPE, static_cast<uint32_t>(_index_type));
  }
  uint32_t skin_id() const {
    return GetField<uint32_t>(VT_SKIN_ID, 0);
  }
  bool mutate_skin_id(uint32_t _skin_id) {
    return SetField(VT_SKIN_ID, _skin_id);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SUBMESHES) &&
           verifier.Verify(submeshes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SUBSETS) &&
           verifier.Verify(subsets()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDICES) &&
           verifier.Verify(indices()) &&
           VerifyField<uint32_t>(verifier, VT_INDEX_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_SKIN_ID) &&
           verifier.EndTable();
  }
};

struct MeshFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertices) {
    fbb_.AddOffset(MeshFb::VT_VERTICES, vertices);
  }
  void add_submeshes(flatbuffers::Offset<flatbuffers::Vector<const SubmeshFb *>> submeshes) {
    fbb_.AddOffset(MeshFb::VT_SUBMESHES, submeshes);
  }
  void add_subsets(flatbuffers::Offset<flatbuffers::Vector<const SubsetFb *>> subsets) {
    fbb_.AddOffset(MeshFb::VT_SUBSETS, subsets);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> indices) {
    fbb_.AddOffset(MeshFb::VT_INDICES, indices);
  }
  void add_index_type(EIndexTypeFb index_type) {
    fbb_.AddElement<uint32_t>(MeshFb::VT_INDEX_TYPE, static_cast<uint32_t>(index_type), 0);
  }
  void add_skin_id(uint32_t skin_id) {
    fbb_.AddElement<uint32_t>(MeshFb::VT_SKIN_ID, skin_id, 0);
  }
  MeshFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshFbBuilder &operator=(const MeshFbBuilder &);
  flatbuffers::Offset<MeshFb> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<MeshFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshFb> CreateMeshFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SubmeshFb *>> submeshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SubsetFb *>> subsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> indices = 0,
    EIndexTypeFb index_type = EIndexTypeFb_UInt16,
    uint32_t skin_id = 0) {
  MeshFbBuilder builder_(_fbb);
  builder_.add_skin_id(skin_id);
  builder_.add_index_type(index_type);
  builder_.add_indices(indices);
  builder_.add_subsets(subsets);
  builder_.add_submeshes(submeshes);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshFb> CreateMeshFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vertices = nullptr,
    const std::vector<const SubmeshFb *> *submeshes = nullptr,
    const std::vector<const SubsetFb *> *subsets = nullptr,
    const std::vector<uint8_t> *indices = nullptr,
    EIndexTypeFb index_type = EIndexTypeFb_UInt16,
    uint32_t skin_id = 0) {
  return CreateMeshFb(
      _fbb,
      vertices ? _fbb.CreateVector<uint8_t>(*vertices) : 0,
      submeshes ? _fbb.CreateVector<const SubmeshFb *>(*submeshes) : 0,
      subsets ? _fbb.CreateVector<const SubsetFb *>(*subsets) : 0,
      indices ? _fbb.CreateVector<uint8_t>(*indices) : 0,
      index_type,
      skin_id);
}

struct MaterialFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_PROPS = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField(VT_ID, _id);
  }
  uint64_t name_id() const {
    return GetField<uint64_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint64_t _name_id) {
    return SetField(VT_NAME_ID, _name_id);
  }
  bool KeyCompareLessThan(const MaterialFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<const MaterialPropFb *> *props() const {
    return GetPointer<const flatbuffers::Vector<const MaterialPropFb *> *>(VT_PROPS);
  }
  flatbuffers::Vector<const MaterialPropFb *> *mutable_props() {
    return GetPointer<flatbuffers::Vector<const MaterialPropFb *> *>(VT_PROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint64_t>(verifier, VT_NAME_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROPS) &&
           verifier.Verify(props()) &&
           verifier.EndTable();
  }
};

struct MaterialFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MaterialFb::VT_ID, id, 0);
  }
  void add_name_id(uint64_t name_id) {
    fbb_.AddElement<uint64_t>(MaterialFb::VT_NAME_ID, name_id, 0);
  }
  void add_props(flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> props) {
    fbb_.AddOffset(MaterialFb::VT_PROPS, props);
  }
  MaterialFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialFbBuilder &operator=(const MaterialFbBuilder &);
  flatbuffers::Offset<MaterialFb> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<MaterialFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialFb> CreateMaterialFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> props = 0) {
  MaterialFbBuilder builder_(_fbb);
  builder_.add_name_id(name_id);
  builder_.add_props(props);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialFb> CreateMaterialFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    const std::vector<const MaterialPropFb *> *props = nullptr) {
  return CreateMaterialFb(
      _fbb,
      id,
      name_id,
      props ? _fbb.CreateVector<const MaterialPropFb *>(*props) : 0);
}

struct NodeFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MESH_ID = 6,
    VT_NAME_ID = 8,
    VT_CULLING_TYPE = 10,
    VT_CHILD_IDS = 12,
    VT_MATERIAL_IDS = 14,
    VT_ANIM_CURVE_IDS = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField(VT_ID, _id);
  }
  uint32_t mesh_id() const {
    return GetField<uint32_t>(VT_MESH_ID, 0);
  }
  bool mutate_mesh_id(uint32_t _mesh_id) {
    return SetField(VT_MESH_ID, _mesh_id);
  }
  uint64_t name_id() const {
    return GetField<uint64_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint64_t _name_id) {
    return SetField(VT_NAME_ID, _name_id);
  }
  bool KeyCompareLessThan(const NodeFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  ECullingType culling_type() const {
    return static_cast<ECullingType>(GetField<uint32_t>(VT_CULLING_TYPE, 0));
  }
  bool mutate_culling_type(ECullingType _culling_type) {
    return SetField(VT_CULLING_TYPE, static_cast<uint32_t>(_culling_type));
  }
  const flatbuffers::Vector<uint32_t> *child_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_CHILD_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_child_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_CHILD_IDS);
  }
  const flatbuffers::Vector<uint32_t> *material_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MATERIAL_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_material_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_MATERIAL_IDS);
  }
  const flatbuffers::Vector<uint32_t> *anim_curve_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ANIM_CURVE_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_anim_curve_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_ANIM_CURVE_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_MESH_ID) &&
           VerifyField<uint64_t>(verifier, VT_NAME_ID) &&
           VerifyField<uint32_t>(verifier, VT_CULLING_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILD_IDS) &&
           verifier.Verify(child_ids()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATERIAL_IDS) &&
           verifier.Verify(material_ids()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM_CURVE_IDS) &&
           verifier.Verify(anim_curve_ids()) &&
           verifier.EndTable();
  }
};

struct NodeFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_ID, id, 0);
  }
  void add_mesh_id(uint32_t mesh_id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_MESH_ID, mesh_id, 0);
  }
  void add_name_id(uint64_t name_id) {
    fbb_.AddElement<uint64_t>(NodeFb::VT_NAME_ID, name_id, 0);
  }
  void add_culling_type(ECullingType culling_type) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_CULLING_TYPE, static_cast<uint32_t>(culling_type), 0);
  }
  void add_child_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> child_ids) {
    fbb_.AddOffset(NodeFb::VT_CHILD_IDS, child_ids);
  }
  void add_material_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> material_ids) {
    fbb_.AddOffset(NodeFb::VT_MATERIAL_IDS, material_ids);
  }
  void add_anim_curve_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> anim_curve_ids) {
    fbb_.AddOffset(NodeFb::VT_ANIM_CURVE_IDS, anim_curve_ids);
  }
  NodeFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeFbBuilder &operator=(const NodeFbBuilder &);
  flatbuffers::Offset<NodeFb> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<NodeFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeFb> CreateNodeFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mesh_id = 0,
    uint64_t name_id = 0,
    ECullingType culling_type = ECullingType_CullingOff,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> child_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> material_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> anim_curve_ids = 0) {
  NodeFbBuilder builder_(_fbb);
  builder_.add_name_id(name_id);
  builder_.add_anim_curve_ids(anim_curve_ids);
  builder_.add_material_ids(material_ids);
  builder_.add_child_ids(child_ids);
  builder_.add_culling_type(culling_type);
  builder_.add_mesh_id(mesh_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeFb> CreateNodeFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mesh_id = 0,
    uint64_t name_id = 0,
    ECullingType culling_type = ECullingType_CullingOff,
    const std::vector<uint32_t> *child_ids = nullptr,
    const std::vector<uint32_t> *material_ids = nullptr,
    const std::vector<uint32_t> *anim_curve_ids = nullptr) {
  return CreateNodeFb(
      _fbb,
      id,
      mesh_id,
      name_id,
      culling_type,
      child_ids ? _fbb.CreateVector<uint32_t>(*child_ids) : 0,
      material_ids ? _fbb.CreateVector<uint32_t>(*material_ids) : 0,
      anim_curve_ids ? _fbb.CreateVector<uint32_t>(*anim_curve_ids) : 0);
}

struct FileFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_BUFFER = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField(VT_ID, _id);
  }
  uint64_t name_id() const {
    return GetField<uint64_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint64_t _name_id) {
    return SetField(VT_NAME_ID, _name_id);
  }
  bool KeyCompareLessThan(const FileFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  flatbuffers::Vector<uint8_t> *mutable_buffer() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint64_t>(verifier, VT_NAME_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct FileFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(FileFb::VT_ID, id, 0);
  }
  void add_name_id(uint64_t name_id) {
    fbb_.AddElement<uint64_t>(FileFb::VT_NAME_ID, name_id, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(FileFb::VT_BUFFER, buffer);
  }
  FileFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileFbBuilder &operator=(const FileFbBuilder &);
  flatbuffers::Offset<FileFb> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<FileFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileFb> CreateFileFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  FileFbBuilder builder_(_fbb);
  builder_.add_name_id(name_id);
  builder_.add_buffer(buffer);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileFb> CreateFileFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint64_t name_id = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  return CreateFileFb(
      _fbb,
      id,
      name_id,
      buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0);
}

struct SceneFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSFORMS = 4,
    VT_NODES = 6,
    VT_MESHES = 8,
    VT_ANIM_STACKS = 10,
    VT_ANIM_LAYERS = 12,
    VT_ANIM_CURVES = 14,
    VT_MATERIALS = 16,
    VT_TEXTURES = 18,
    VT_SKINS = 20,
    VT_FILES = 22,
    VT_NAMES = 24
  };
  const flatbuffers::Vector<const TransformFb *> *transforms() const {
    return GetPointer<const flatbuffers::Vector<const TransformFb *> *>(VT_TRANSFORMS);
  }
  flatbuffers::Vector<const TransformFb *> *mutable_transforms() {
    return GetPointer<flatbuffers::Vector<const TransformFb *> *>(VT_TRANSFORMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *>(VT_NODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *mutable_nodes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *>(VT_MESHES);
  }
  flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *mutable_meshes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<const AnimStackFb *> *anim_stacks() const {
    return GetPointer<const flatbuffers::Vector<const AnimStackFb *> *>(VT_ANIM_STACKS);
  }
  flatbuffers::Vector<const AnimStackFb *> *mutable_anim_stacks() {
    return GetPointer<flatbuffers::Vector<const AnimStackFb *> *>(VT_ANIM_STACKS);
  }
  const flatbuffers::Vector<const AnimLayerFb *> *anim_layers() const {
    return GetPointer<const flatbuffers::Vector<const AnimLayerFb *> *>(VT_ANIM_LAYERS);
  }
  flatbuffers::Vector<const AnimLayerFb *> *mutable_anim_layers() {
    return GetPointer<flatbuffers::Vector<const AnimLayerFb *> *>(VT_ANIM_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *anim_curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *>(VT_ANIM_CURVES);
  }
  flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *mutable_anim_curves() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *>(VT_ANIM_CURVES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *>(VT_MATERIALS);
  }
  flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *mutable_materials() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<const TextureFb *> *textures() const {
    return GetPointer<const flatbuffers::Vector<const TextureFb *> *>(VT_TEXTURES);
  }
  flatbuffers::Vector<const TextureFb *> *mutable_textures() {
    return GetPointer<flatbuffers::Vector<const TextureFb *> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *skins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *>(VT_SKINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *mutable_skins() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *>(VT_SKINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FileFb>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FileFb>> *>(VT_FILES);
  }
  flatbuffers::Vector<flatbuffers::Offset<FileFb>> *mutable_files() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FileFb>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NameFb>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NameFb>> *>(VT_NAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<NameFb>> *mutable_names() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<NameFb>> *>(VT_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSFORMS) &&
           verifier.Verify(transforms()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESHES) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM_STACKS) &&
           verifier.Verify(anim_stacks()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM_LAYERS) &&
           verifier.Verify(anim_layers()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM_CURVES) &&
           verifier.Verify(anim_curves()) &&
           verifier.VerifyVectorOfTables(anim_curves()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MATERIALS) &&
           verifier.Verify(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTURES) &&
           verifier.Verify(textures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SKINS) &&
           verifier.Verify(skins()) &&
           verifier.VerifyVectorOfTables(skins()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILES) &&
           verifier.Verify(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAMES) &&
           verifier.Verify(names()) &&
           verifier.VerifyVectorOfTables(names()) &&
           verifier.EndTable();
  }
};

struct SceneFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transforms(flatbuffers::Offset<flatbuffers::Vector<const TransformFb *>> transforms) {
    fbb_.AddOffset(SceneFb::VT_TRANSFORMS, transforms);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeFb>>> nodes) {
    fbb_.AddOffset(SceneFb::VT_NODES, nodes);
  }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshFb>>> meshes) {
    fbb_.AddOffset(SceneFb::VT_MESHES, meshes);
  }
  void add_anim_stacks(flatbuffers::Offset<flatbuffers::Vector<const AnimStackFb *>> anim_stacks) {
    fbb_.AddOffset(SceneFb::VT_ANIM_STACKS, anim_stacks);
  }
  void add_anim_layers(flatbuffers::Offset<flatbuffers::Vector<const AnimLayerFb *>> anim_layers) {
    fbb_.AddOffset(SceneFb::VT_ANIM_LAYERS, anim_layers);
  }
  void add_anim_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>>> anim_curves) {
    fbb_.AddOffset(SceneFb::VT_ANIM_CURVES, anim_curves);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>>> materials) {
    fbb_.AddOffset(SceneFb::VT_MATERIALS, materials);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<const TextureFb *>> textures) {
    fbb_.AddOffset(SceneFb::VT_TEXTURES, textures);
  }
  void add_skins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinFb>>> skins) {
    fbb_.AddOffset(SceneFb::VT_SKINS, skins);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileFb>>> files) {
    fbb_.AddOffset(SceneFb::VT_FILES, files);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NameFb>>> names) {
    fbb_.AddOffset(SceneFb::VT_NAMES, names);
  }
  SceneFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneFbBuilder &operator=(const SceneFbBuilder &);
  flatbuffers::Offset<SceneFb> Finish() {
    const auto end = fbb_.EndTable(start_, 11);
    auto o = flatbuffers::Offset<SceneFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<SceneFb> CreateSceneFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const TransformFb *>> transforms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeFb>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshFb>>> meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AnimStackFb *>> anim_stacks = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AnimLayerFb *>> anim_layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>>> anim_curves = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TextureFb *>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinFb>>> skins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileFb>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NameFb>>> names = 0) {
  SceneFbBuilder builder_(_fbb);
  builder_.add_names(names);
  builder_.add_files(files);
  builder_.add_skins(skins);
  builder_.add_textures(textures);
  builder_.add_materials(materials);
  builder_.add_anim_curves(anim_curves);
  builder_.add_anim_layers(anim_layers);
  builder_.add_anim_stacks(anim_stacks);
  builder_.add_meshes(meshes);
  builder_.add_nodes(nodes);
  builder_.add_transforms(transforms);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneFb> CreateSceneFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const TransformFb *> *transforms = nullptr,
    const std::vector<flatbuffers::Offset<NodeFb>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<MeshFb>> *meshes = nullptr,
    const std::vector<const AnimStackFb *> *anim_stacks = nullptr,
    const std::vector<const AnimLayerFb *> *anim_layers = nullptr,
    const std::vector<flatbuffers::Offset<AnimCurveFb>> *anim_curves = nullptr,
    const std::vector<flatbuffers::Offset<MaterialFb>> *materials = nullptr,
    const std::vector<const TextureFb *> *textures = nullptr,
    const std::vector<flatbuffers::Offset<SkinFb>> *skins = nullptr,
    const std::vector<flatbuffers::Offset<FileFb>> *files = nullptr,
    const std::vector<flatbuffers::Offset<NameFb>> *names = nullptr) {
  return CreateSceneFb(
      _fbb,
      transforms ? _fbb.CreateVector<const TransformFb *>(*transforms) : 0,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeFb>>(*nodes) : 0,
      meshes ? _fbb.CreateVector<flatbuffers::Offset<MeshFb>>(*meshes) : 0,
      anim_stacks ? _fbb.CreateVector<const AnimStackFb *>(*anim_stacks) : 0,
      anim_layers ? _fbb.CreateVector<const AnimLayerFb *>(*anim_layers) : 0,
      anim_curves ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveFb>>(*anim_curves) : 0,
      materials ? _fbb.CreateVector<flatbuffers::Offset<MaterialFb>>(*materials) : 0,
      textures ? _fbb.CreateVector<const TextureFb *>(*textures) : 0,
      skins ? _fbb.CreateVector<flatbuffers::Offset<SkinFb>>(*skins) : 0,
      files ? _fbb.CreateVector<flatbuffers::Offset<FileFb>>(*files) : 0,
      names ? _fbb.CreateVector<flatbuffers::Offset<NameFb>>(*names) : 0);
}

inline const apemodefb::SceneFb *GetSceneFb(const void *buf) {
  return flatbuffers::GetRoot<apemodefb::SceneFb>(buf);
}

inline SceneFb *GetMutableSceneFb(void *buf) {
  return flatbuffers::GetMutableRoot<SceneFb>(buf);
}

inline const char *SceneFbIdentifier() {
  return "FBXP";
}

inline bool SceneFbBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SceneFbIdentifier());
}

inline bool VerifySceneFbBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<apemodefb::SceneFb>(SceneFbIdentifier());
}

inline const char *SceneFbExtension() {
  return "apemode";
}

inline void FinishSceneFbBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apemodefb::SceneFb> root) {
  fbb.Finish(root, SceneFbIdentifier());
}

}  // namespace apemodefb

#endif  // FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_
